# 오픈소스sw개론 과제
## ___top 명령어___
__top 명령어란?__

리눅스 시스템의 운용상황을 실시간으로 전반적인 상황을 모니터링하거나 프로세스를 관리할 수 있는 명령어이다.

-___아래 사진은 top명령어를 실행했을 때 이다.___-
<img src="https://user-images.githubusercontent.com/97230837/171996611-62ba43a0-4750-46fe-a795-a93a519e5bdc.png" width = "700" height="400">

1. 첫번째 줄의 정보

__Load Average__

세 개의 숫자는 각각 1분, 5분, 15분 간의 평균 실행/대기 중인 프로세스의 수를 나타내고, uptime 명령어로도 확인할 수 있으며, 시스템 부하를 모니터링 할 수 있다. 숫자가 높을 수록 시스템에 부하가 있다는 것이다. load average 값은 CPU의 코어 수를 같이 확인해야 하며, 코어 수 보다 적으면 문제가 없는 것이다.

2. 두번째 줄의 정보

__Tasks__

Tasks는 현재 프로세스들의 상태를 나태내주는 영역입니다. Total은 전체 프로세스, running은 running 상태인 프로세스, sleeping은 대기상태인 process, stopped는 종료된 프로세스, zombies는 좀비상태인 프로세스의 수를 나타냅니다.

3. 세번째 줄의 정보

__CPU 사용량__

이 영역은 CPU가 어떻게 사용되고 있는지 그 사용율을 보여주는 영역입니다. 모든 값의 총 합은 100% 이며 이를 퍼센테이지로 나누어서 보여줍니다. 각 요소는 아래와 같습니다.

- us : 프로세스의 유저 영역에서의 CPU 사용률
- sy : 프로세스의 커널 영역에서의 CPU 사용률
- ni : 프로세스의 우선순위(priority) 설정에 사용하는 CPU 사용률
- id : 사용하고 있지 않는 비율
- wa : IO가 완료될때까지 기다리고 있는 CPU 비율
- hi : 하드웨어 인터럽트에 사용되는 CPU 사용률
- si : 소프트웨어 인터럽트에 사용되는 CPU 사용률
- st : CPU를 VM에서 사용하여 대기하는 CPU 비율

4. 네번째 줄의 정보

__메모리 사용량__

첫번째 줄은 RAM의 메모리 영역으로 Mem이라 표시되어있는 부분입니다. 그리고 아랫줄은 디스크를 메모리 처럼 이용하는 Swap 메모리 영역입니다. 일반적으로 Mem의 사용량이 거의 가득 찼을때 Swap 메모리 영역을 사용합니다. 이 영역은 디스크이기 때문에 RAM 메모리보다 속도가 많이 느린 단점을 가집니다.

- total : 총 메모리 양
- free : 사용가능한 메모리 양
- used : 사용중인 메모리 양

5. 5번째 줄의 아래 정보

__세부 정보__

- 위 사진에 노란색으로 표시된 곳이 세부 정보 이름이고 아래 나와있는 것이 세부 정보이다.

|세부 정보|표시하고 있는 정보의 의미|
|:---:|:---|
|PID|프로세스 ID(process ID)|
|USER|프로세스를 실행시킨 사용자의 ID|
|PRI|프로세스의 우선순위|
|NI|PR에 영향을 주는 nice라는 값입니다. 일의 nice value값이다. 마이너스를 가지는 nice value는 우선순위가 높음.|
|VIRT|가상 메모리의 사용량이다. 실행중인 코드,heap,stack과 같은 메모리,IO buffer메모리를 포함합니다.|
|RES|RAM에서 사용중인 메모리의 크기를 나타냅니다.|
|SHR|다른 프로세스와의 공유메모리(Shared Memory)를 나타냅니다.|
|S|프로세스의 현재 상태를 의미합니다. S(sleeping), R(running), W(swapped out process), Z(zombies)|
|%CPU|프로세스가 사용하는 CPU의 사용율을 나타냅니다.|
|%MEM|프로세스가 사용하는 메모리의 사용율 나타냅니다.|
|TIME+|프로세스가 시작된 이후 경가된 총 시간을 나타냅니다.|
|COMMAND|실행된 멸령어를 나타냅니다.|

__top 실행 후 사용할 수 있는 명령어__

|명령어|실행|
|:---|:---|
|shift + p|CPU 사용률이 높은 프로세스 순서대로 표시|
|shift + m|메모리 사용률이 높은 프로세스 순서대로 표시|
|shift + t|프로세스가 돌아가고 있는 시간 순서대로 표시|
|k|프로세스  kill  - k 입력 후 종료할 PID 입력 signal을 입력하라고 하면 kill signal인 9를 입력|
|c|명령 인자 표시/비표시|
|l|uptime line을 표시/비표시|
|space bar|Refresh|
|u|입력한 유저 소유의 process만 표시|
|f|화면에 표시될 프로세스 관련 항목 설정|
|i|idle또는 좀비 상태의 프로세스는 표시 하지 않음|
|z|출력 색상 변경|
|d [sec]|설정된 초단위로 Refresh|
|q|명령어 종료|

__top 실행 전 사용할 수 있는 명령어__

- b	: 배치모드 옵션
- n	: top 실행 주기를 설정
- p	: process ID 

---

##  ___ps 명령어___

__ps 명령어란?__

ps 명령어는 현재 돌아가고 있는 프로세스를 확인할 수 있는 명령어입니다.(Process Status)
-윈도우의 작업관리자 같은 거라고 생각하면 됩니다.

-___아래 사진은 ps -efl명령어를 실행했을 때 화면이다.___-

<img src="https://user-images.githubusercontent.com/97230837/171998196-5198060f-eb3b-4abb-aaed-9467140ccd93.PNG" width = "700" height="400">

1. 세부 정보 표시

- 위 사진에 첫번째 줄이 세부 정보란이다.

|세부 정보 이름|정보 의미|
|:---|:---|
|UID|실행 유저|
|PID|프로세스 ID|
|PPID|부모 프로세스 PID|
|C|CPU 사용량|
|STIME|Start Time|
|TTY|프로세스 제어 위치|
|TIME|구동 시간|
|CMD|실행 명령어|

2. ps 사용법

$ps [option]
|옵션|의미|
|:---|:---|
|-A|모든 프로세스를 출력한다.|
|-a|터미널에 종속되지 않은 프로세스를 출력한다.|
|-e|커널 프로세스를 제외한 모든 프로세스를 출력한다.|
|-f|풀 포맷으로 보여준다.(UID,PID,PPID등이 함께 표시됨)|
|-o|출력 포맷을 지정하는 옵션, pid,tty,time,cmd등을 지정할 수 있다.|
|-M|64비트 프로세스를 보여준다.|
|-l|긴 포멧으로 보여준다.(정보가 더많음 PRI,NI값)|
|-m|프로세스들 뿐만 아니라 커널 스레드들도 보여준다.|
|-p|특정 PID를 지정할 때 사용한다.|
|-r|현재 실행중인 프로세서를 보여준다.|
|-u|특정 사용자의 프로세스 정보를 확인한다.|
|-x|로그인 상태에 있는 동안 아직 완료되지 않은 프로세서들을 보여준다.|

특정 프로세스를 확인하기 위해 grep이라는 명령어와 함께 자주 사용됨
ps -ef|grep '프로세스명'

3. 예시

$ps -fp [PID]
-PID를 키워드로 프로세스 정보를 확인하는 옵션

ex)ps -fp 1219 
```
-f 옵션로 -> full format으로 출력
                 
-p 옵션으로 PID가 1219인 프로세스 정보를 출력
               
합치면 PID가 1219인 프로세스 정보를 full format으로 출력해줘
```

